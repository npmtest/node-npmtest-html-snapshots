{"/home/travis/build/npmtest/node-npmtest-html-snapshots/test.js":"/* istanbul instrument in package npmtest_html_snapshots */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/lib.npmtest_html_snapshots.js":"/* istanbul instrument in package npmtest_html_snapshots */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_html_snapshots = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_html_snapshots = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-html-snapshots && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_html_snapshots */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_html_snapshots\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_html_snapshots.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_html_snapshots.rollup.js'] =\n            local.assetsDict['/assets.npmtest_html_snapshots.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_html_snapshots.__dirname + '/lib.npmtest_html_snapshots.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/html-snapshots.js":"/*\n * html-snapshots.js\n *\n * Produce html snapshots using for a website for SEO purposes.\n * This is required for javascript SPAs or ajax page output.\n * By default, uses a selector to search content to determine if\n *   a page is \"ready\" for its html snapshot.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n/* global Promise */\n\"use strict\";\n\nvar spawn = require(\"child_process\").spawn;\nvar path = require(\"path\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar rimraf = require(\"rimraf\").sync;\nvar asyncLib = require(\"async\");\nvar _ = require(\"lodash\");\n\nvar common = require(\"./common\");\nvar inputFactory = require(\"./input-generators\");\nvar Notifier = require(\"./async\").Notifier;\nvar phantomDir = \"./phantom\";\nvar snapshotScript = path.join(phantomDir, \"default.js\");\n\n/**\n * Determine the default phantomJS module path. This is overridden by the\n * phatomjs option.\n *\n * This function, (technique and concerns) originated from karma-phantomjs-launcher:\n *\n * The MIT License\n * Copyright (C) 2011-2013 Google, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n */\nvar defaultPhantomJSExePath = function () {\n  // If the path we're given by phantomjs is to a .cmd, it is pointing to a global copy.\n  // Using the cmd as the process to execute causes problems cleaning up the processes\n  // so we walk from the cmd to the phantomjs.exe and use that instead.\n\n  var phantomSource = require(\"phantomjs-prebuilt\").path;\n\n  if (path.extname(phantomSource).toLowerCase() === \".cmd\") {\n    return path.join(path.dirname( phantomSource ), \"//node_modules//phantomjs-prebuilt//lib//phantom//bin//phantomjs.exe\");\n  }\n\n  return phantomSource;\n};\n\n/**\n * This module's defaults\n */\nvar defaults = Object.freeze({\n  input: \"robots\",\n  phantomjs: defaultPhantomJSExePath(),\n  snapshotScript: path.join(__dirname, snapshotScript),\n  outputDirClean: false,\n  pollInterval: 500,\n  processLimit: 4\n});\n\n/**\n * The worker task that launches phantomjs.\n *\n * @param {Object} input - An input object from an input generator.\n * @param {Array} input.phantomjsOptions - Actual Phantomjs options.\n * @param {String} input.outputFile - The output file that the html is written to.\n * @param {String} input.url - The url to get the html from.\n * @param {String} input.selector - The selector to wait for.\n * @param {String} input.timeout - The phantomjs timeout.\n * @param {String} input.checkInterval - The interval to poll for results.\n * @param {Boolean} input.useJQuery - True if selector is jquery selector.\n * @param {Boolean} input.verbose - True if verbose output is desired.\n * @param {Object} options - Input options.\n * @param {Object} options.snapshotScript - Snapshot script options.\n * @param {String} options.snapshotScript.script - Snapshot script name.\n * @param {String} options.snapshotScript.module - Snapshot script module.\n * @param {String} options.phantomjs - Full path to the Phantomjs exe.\n * @param {Object} notifier - The async Notifier instance for this run.\n * @param {Function} notifier.remove - Remove an outputFile from notifier.\n * @param {Function} notifier.setError - Set an error on the notifier.\n * @param {Function} notifier.add - Add a file, timeout to the notifier.\n * @param {Function} notifier.known - Check if a file is or has been processed.\n * @param {Function} qcb - async.queue callback function.\n */\nfunction worker (input, options, notifier, qcb) {\n  var cp,\n      customModule,\n      snapshotScript = options.snapshotScript,\n      phantomjsOptions = Array.isArray(input.phantomjsOptions) ? input.phantomjsOptions : [input.phantomjsOptions];\n\n  // If the outputFile has NOT already been seen by the notifier, process.\n  if (!notifier.known(input.outputFile)) {\n\n    // map snapshotScript object script to a real path\n    if (_.isObject(options.snapshotScript)) {\n      snapshotScript = path.join(__dirname, phantomDir, options.snapshotScript.script) + \".js\";\n      customModule = options.snapshotScript.module;\n    }\n\n    cp = spawn(\n      options.phantomjs,\n      phantomjsOptions.concat([\n        snapshotScript,\n        input.outputFile,\n        input.url,\n        input.selector,\n        input.timeout,\n        input.checkInterval,\n        input.useJQuery,\n        input.verbose,\n        customModule\n      ]), { cwd: process.cwd(), stdio: \"inherit\", detached: true }\n    );\n\n    cp.on(\"error\", function (e) {\n      notifier.remove(input.outputFile);\n      notifier.setError(e);\n      console.error(e);\n      qcb(e);\n    });\n\n    cp.on(\"exit\", function (code) {\n      qcb(code);\n    });\n\n    // start counting\n    notifier.add(input.outputFile, input.timeout);\n  }\n  else {\n    // The input.outputFile is being or has been processed this run.\n    qcb(0);\n  }\n}\n\n/**\n * Prepare html snapshots options.\n *\n * @param {Object} options - html snapshots options.\n * @param {Array|String} options.source - html snapshots data source.\n */\nfunction prepOptions (options) {\n  // ensure this module's defaults are represented in the options.\n  common.ensure(options, defaults);\n\n  // if array data source, ensure input type is \"array\".\n  if (Array.isArray(options.source)) {\n    options.input = \"array\";\n  }\n}\n\nmodule.exports = {\n  /**\n   * Run all the snapshots using the requested inputGenerator\n   *\n   * @param {Object} options - ALL user supplied html snapshots options.\n   * @param {String} options.outputDir - Directory to write the html files to.\n   * @param {String} [options.input] - Input source type \"robots\", \"sitemap\", \"array\";\n   * Defaults to \"robots\".\n   * @param {Boolean} [options.outputDirClean] - True if output dir should be rm -rf;\n   * Defaults to false.\n   * @param {Number} [options.pollInterval] -\n   * @param {Function} [listener] - User supplied optional callback.\n   * @returns {Promise} Resolves on completion.\n   */\n  run: function (options, listener) {\n    var inputGenerator, notifier, started, result, q, emitter, completion;\n\n    options = options || {};\n    prepOptions(options);\n\n    // create the inputGenerator, default to robots\n    inputGenerator = inputFactory.create(options.input);\n\n    // clean the snapshot output directory\n    if (options.outputDirClean) {\n      rimraf(options.outputDir);\n    }\n\n    // start async completion notification.\n    notifier = new Notifier();\n    emitter = new EventEmitter();\n    started = notifier.start(options.pollInterval, inputGenerator,\n      function (err, completed) {\n        emitter.emit(\"complete\", err, completed);\n      });\n\n    if (started) {\n      // create the completion Promise.\n      completion = new Promise(function (resolve, reject) {\n        function completionResolver (err, completed) {\n          try {\n            _.isFunction(listener) && listener(err, completed);\n          } catch (e) {\n            console.error(\"User supplied listener exception\", e);\n          }\n          if (err) {\n            err.notCompleted = notifier.filesNotDone;\n            err.completed = completed;\n            reject(err);\n          } else {\n            resolve(completed);\n          }\n        }\n        emitter.addListener(\"complete\", completionResolver);\n      });\n\n      // create a worker queue with a parallel process limit.\n      q = asyncLib.queue(function (task, callback) {\n        task(_.once(callback));\n      }, options.processLimit);\n\n      // have the queue call notifier.empty when last item\n      //  from the queue is given to a worker.\n      q.empty = notifier.qEmpty.bind(notifier);\n\n      // expose abort callback to input generators via options.\n      options._abort = function (err) {\n        notifier.abort(q, err);\n      };\n\n      // generate input for the snapshots.\n      result = inputGenerator.run(options, function (input) {\n        // give the worker the input and place into the queue\n        q.push(_.partial(worker, input, options, notifier));\n      })\n        // after input generation, resolve on browser completion.\n        .then(function () {\n          return completion;\n        });\n    } else {\n      result = Promise.reject(\"failed to start async notifier\");\n    }\n\n    return result;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/common/index.js":"/**\n * common code\n *\n * Copyright (c) 2013 - 2017, Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * Ensures that options at least contains propties and values from must\n   * if they're not already defined and not null.\n   * Differs from underscore by replacing\n   *   undefined *or null* falsies, and only one defaults source allowed.\n   */\n  ensure: function (options, must) {\n    if (must) {\n      for (var prop in must) {\n        if (options[prop] === void 0 || options[prop] === null) {\n          options[prop] = must[prop];\n        }\n      }\n    }\n    return options;\n  },\n\n  /**\n   * simple test for url\n   * If you can think of a more approriate test for this use case,\n   *   please let me know in the issues...\n   */\n  isUrl: function (obj) {\n    var result = false;\n    if (typeof obj === \"string\") {\n      return (/^https?:\\/\\//).test(obj);\n    }\n    return result;\n  },\n\n  /**\n   * Prepend a message to an Error message.\n   *\n   * @param {Object} [error] - An instance of Error. If not, converted to Error.\n   * If undefined, then pass through undefined.\n   * @param {String} [message] - The message to prepend.\n   * @param {Boolean} [quoteInput] - True if the message should be quoted.\n   * @returns {Error} The updated Error instance, undefined if no error.\n   */\n  prependMsgToErr: function (error, message, quoteInput) {\n    var result, prepend, empty = \"\", quote = \"'\";\n\n    if (error) {\n      if (message) {\n        prepend = quoteInput ? empty.concat(quote, message, quote) : message;\n      }\n\n      // Force Error instance, coerce given error to a string\n      error = error instanceof Error ? error : new Error(empty + error);\n\n      // If message supplied, prepend it\n      error.message =\n        prepend ? empty.concat(prepend, \": \", error.message) : error.message;\n\n      result = error;\n    }\n\n    return result;\n  },\n\n  /**\n   * Simple response checker for remote files.\n   * Expected use in robots.txt or sitemap.xml only.\n   *\n   * @param {IncomingMessage} res - The IncomingMessage response to check.\n   * @param {Array} mediaTypes - array of acceptable content-type media type strings.\n   * @returns {String} Error message, empty string (falsy) if OK.\n   */\n  checkResponse: function (res, mediaTypes) {\n    var contentTypeOk,\n        result = \"status: '\" + res.statusCode + \"', GET failed.\";\n\n    mediaTypes = !Array.isArray(mediaTypes) ? [mediaTypes] : mediaTypes;\n\n    if (res.statusCode === 200) {\n      // if content-type exists, and media type found then contentTypeOk\n      contentTypeOk =\n        res.headers[\"content-type\"] &&\n        // empty array and none found return true\n        !mediaTypes.every(function(mediaType) {\n          // flip -1 to 0 and NOT, so that true == NOT found, found stops loop w/false\n          return !~res.headers[\"content-type\"].indexOf(mediaType);\n        });\n\n      result = contentTypeOk ? \"\" : \"content-type not one of '\"+mediaTypes.join(\",\")+\"'\";\n    }\n\n    return result;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/input-generators/index.js":"/**\n * index.js\n *\n * Input generator factory\n * Create an input generator that produces snapshots arguments\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nmodule.exports = {\n  /**\n   * create\n   * Creates the input generator based on the input string, which must match a\n   * js file in this directory.\n   * So, if input === \"robots\", then executes require(\"./robots\");\n   * Unsupported input generator types return a \"null\" generator.\n   *\n   * @param {String} input - The name of the input generator to create.\n   * @returns {Object} The input generator, a null generator on error.\n   */\n  create: function (input) {\n    var result = {\n      run: function () {\n        return [];\n      },\n      __null: true\n    },\n    hasInput;\n\n    if (input) {\n      input = (\"\"+input).replace(\" \", \"\").toLowerCase();\n      hasInput = input && input.charAt(0) !== '_' && input !== \"index\";\n    }\n\n    try {\n      if (hasInput) {\n        result = require( \"./\" + input);\n      }\n    } catch (e) {\n      console.error(\"Input generator load failed '\" + input + \"'\", e)\n      /* return the \"null\" generator on error */\n    }\n\n    return result;\n  },\n\n  /**\n   * Determine if an input generator is null (bogus).\n   * If the generator has __null defined, then its bogus.\n   *\n   * @param {Object} generator - An input generator.\n   * @returns {Boolean} True if the given generator is bogus, false otherwise.\n   */\n  isNull: function (generator) {\n    return generator.__null !== void 0;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/async/index.js":"/**\n * index.js\n *\n * Async stuff for html-snapshots\n *   Notifier class\n *\n * Copyright (c) 2013 - 2017, Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n/* global Promise */\n\"use strict\";\n\nvar crypto = require(\"crypto\");\nvar AsyncLock = require(\"async-lock\");\nvar combineErrors = require(\"combine-errors\");\nvar pathExists = require(\"./exists\");\n\nvar L_WAIT = 10000;\nvar TIMEOUT_PAD_FLOOR = 800;\nfunction NOOP () {}\n\n/**\n * Create the lock factory.\n */\nfunction createLockFactory () {\n  // Create the per instance async lock.\n  var lock = new AsyncLock();\n\n  // Make a random id\n  var rid = crypto.randomBytes(16).toString(\"hex\");\n\n  /**\n   * Force a serial execution context.\n   *\n   * @param {Function} fn - The function to guard.\n   * @param {Number} timeout - The max time to wait for the lock.\n   */\n  return function lockFactory (fn, timeout) {\n    return function protectedContext () {\n      lock.acquire(\"cs-guard-\" + rid, function (done) {\n        fn(function () {\n          done(null, 0);\n        });\n      }, NOOP, {\n        timeout: timeout\n      });\n    };\n  };\n}\n\n/**\n * Notifier Constructor\n * Polls the outputDir and when all the files exist,\n * calls the listener indicating the snapshots are done.\n */\nfunction Notifier () {\n\n  // Create the serial execution context mechanism.\n  this.csFactory = createLockFactory();\n\n  // The private files collection\n  // Contains a file and timer: \"filename\": {timer: timerid}\n  // Used for tracking work left to do. When empty, work is done.\n  this.files = {};\n\n  // Contains files successfully processed\n  this.filesDone = [];\n\n  // Contains files unsuccessfully processed\n  this.filesNotDone = [];\n\n  // true if a timeout occurred, or set by abort\n  this.errors = [];\n\n  // the holder of the current failure timeout padding\n  this.padTimeout = TIMEOUT_PAD_FLOOR;\n\n  // our reference to the listener\n  this.callback = null;\n\n  // our reference to the watcher (an interval id)\n  // initial value undefined is important\n  // this.watcher;\n\n  // the working pollInterval for this run\n  // this.interval\n\n  // flag set by qEmpty callback\n  // when the last item from the queue is given to a worker\n  this.qempty = false;\n}\n\nNotifier.prototype = {\n  /**\n   * Set the qempty flag to true.\n   */\n  qEmpty: function qEmpty () {\n    this.qempty = true;\n  },\n\n  /**\n   * Start a watch interval, when a file exists, remove it from our files array.\n   * If the files array is empty, call the listener and stop the watch interval.\n   *\n   * @param {Number} pollInterval - The millisecond poll interval to check for\n   * file completion.\n   * @param {Object} input - The inputGenerator.\n   * @param {Function} listener - The callback to notify when complete.\n   * @param {Function} input.EOI - The inputGenerator function that signals end\n   * of input.\n   * @returns {Boolean} true if started successfully, false otherwise.\n   */\n  start: function start (pollInterval, input, listener) {\n    var result = (\n      pollInterval > 0 &&\n      typeof listener === \"function\" &&\n      (!!input)\n      );\n\n    if (result) {\n      if (this.isStarted()) {\n        throw new Error(\"Notifier already started\");\n      }\n\n      this.callback = listener;\n      this.interval = parseInt(pollInterval, 10);\n\n      // Poll the filesystem for the files to exist\n      // Checks the child process expected output to determine success or failure\n      // if the file exists, then it succeeded.\n      this.watcher = setInterval(this.csFactory(function (done) {\n        var self = this;\n        var eoi = typeof input.EOI === \"function\" && input.EOI();\n\n        if (eoi) {\n          Promise.all(Object.keys(self.files).map(function (file) {\n            return pathExists(file, {\n              returnFile: true\n            });\n          }))\n            .then(function (files) {\n              var callback = self.callback;\n\n              try {\n                files.forEach(function (file) {\n                  file && self._remove(file, true);\n                });\n\n                if (self._isDone()) {\n                  self._closeWatcher();\n                  if (self.callback) {\n                    self.callback = null;\n                    setImmediate(function () {\n                      callback(self.getError(), self.filesDone);\n                    });\n                  }\n                }\n              } catch (e) {\n                console.error(e);\n              }\n              done();\n            });\n        } else {\n          done();\n        }\n      }.bind(this), L_WAIT), this.interval);\n\n    } else {\n      console.error(\"Bad poll interval, async listener, or input generator supplied\");\n    }\n\n    return result;\n  },\n\n  /**\n   * Indicates if start has been called.\n   *\n   * @returns {Boolean} true if start has been called, false otherwise.\n   */\n  isStarted: function isStarted () {\n    return (typeof this.watcher !== \"undefined\");\n  },\n\n  /**\n   * Add a file to the files array if it's not there.\n   *\n   * @param {String} outputFile - The full path to the output file to add.\n   * @param {Number} timeout - timeout milliseconds to wait (max).\n   */\n  add: function add (outputFile, timeout) {\n    var failTimeout = timeout;\n    var timer;\n\n    if (!this.isStarted()) {\n      throw new Error(\"MUST call `start` before `add`\");\n    }\n\n    if (!this._exists(outputFile)) {\n      // make sure we evaluate after the child process\n      failTimeout = parseInt(timeout, 10) + parseInt(this.padTimeout, 10);\n      // Stagger and grow the failure timeout padding, add 1s every 10 processes\n      this.padTimeout += 100;\n\n      // setup a timeout handler to detect failure\n      timer = setTimeout(this.csFactory(function (done) {\n        var self = this;\n\n        // if the output file has not already been removed\n        if (self._exists(outputFile)) {\n          pathExists(outputFile)\n            .then(function (fsExists) {\n              var callback = self.callback;\n\n              try {\n                if (!fsExists) {\n                  self._setError(new Error(\n                    \"'\" + outputFile + \"' did not get a snapshot before timeout\"\n                  ));\n                }\n                self._remove(outputFile, fsExists);\n\n                if (self._isDone()) {\n                  self._closeWatcher();\n                  if (self.callback) {\n                    self.callback = null;\n                    setImmediate(function () {\n                      callback(self.getError(), self.filesDone);\n                    });\n                  }\n                }\n              } catch (e) {\n                console.error(e);\n              }\n              done();\n            });\n        } else {\n          done();\n        }\n      }.bind(this), L_WAIT), parseInt(failTimeout, 10));\n\n      // add the file tracking object\n      this.files[outputFile] = {\n        timer: timer\n      };\n    }\n  },\n\n  /**\n   * Check if a file exists in the internal files array.\n   *\n   * @param {String} outputFile - The outputFile to check.\n   * @returns {Boolean} true if the file exists, false otherwise.\n   */\n  _exists: function _exists (outputFile) {\n    return (!!this.files[outputFile]);\n  },\n\n  /**\n   * Check if a file is being processed or has already been processed.\n   *\n   * @param {String} outputFile - The outputFile to check.\n   * @returns {Boolean} true if the fi\n   */\n  known: function known (outputFile) {\n    var result = false;\n    this.csFactory(function (done) {\n      result =\n        this._exists(outputFile) || this.filesDone.indexOf(outputFile) > -1;\n      done();\n    }.bind(this), L_WAIT)();\n    return result;\n  },\n\n  /**\n   * Remove a file from the files array if it's there.\n   * Unprotected version.\n   *\n   * @param {String} outputFile - The outputFile to remove.\n   * @param {Boolean} done - If true, add to filesDone collection.\n   */\n  _remove: function _remove (outputFile, done) {\n    if (this._exists(outputFile)) {\n      if (done) {\n        this.filesDone.push(outputFile);\n      } else {\n        this.filesNotDone.push(outputFile);\n      }\n      clearTimeout(this.files[outputFile].timer);\n      delete this.files[outputFile];\n    }\n  },\n\n  /**\n   * Remove a file from the files array if it's there.\n   * Protected version.\n   *\n   * @param {String} outputFile - The outputFile to remove.\n   * @param {Boolean} done - If true, add to filesDone collection.\n   */\n  remove: function remove (outputFile, done) {\n    this.csFactory(function (_done) {\n      this._remove(outputFile, done);\n      _done();\n    }.bind(this), L_WAIT)();\n  },\n\n  /**\n   * Audit the file count.\n   *\n   * @returns {Number} the number of files being watched at the moment.\n   */\n  _fileCount: function _fileCount () {\n    return Object.keys(this.files).length;\n  },\n\n  /**\n   * Check if there is anything left to watch.\n   *\n   * @returns {Boolean} true if processing is done, false otherwise.\n   */\n  _isDone: function _isDone () {\n    return this._fileCount() === 0 && this.qempty;\n  },\n\n  /**\n   * Set the error, saves to a collection of errors.\n   * Unprotected version.\n   *\n   * @param {Object} value - The error to set.\n   */\n  _setError: function _setError (value) {\n    this.errors.push(value);\n  },\n\n  /**\n   * Set the error property, if not already set.\n   * Protected version.\n   *\n   * @param {Object} value - The error to set.\n   */\n  setError: function setError (value) {\n    this.csFactory(function (done) {\n      this._setError(value);\n      done();\n    }.bind(this), L_WAIT)();\n  },\n\n  /**\n   * Get the error property.\n   *\n   * @returns {Object} The error property.\n   */\n  getError: function getError () {\n    return this.errors.length > 0 ? combineErrors(this.errors) : undefined;\n  },\n\n  /**\n   * End file watching.\n   */\n  _closeWatcher: function _closeWatcher () {\n    if (this.watcher) {\n      clearInterval(this.watcher);\n      this.watcher = null;\n    }\n  },\n\n  /**\n   * Provides a way to abort what this is doing.\n   * Causes conditions so that, if isStarted, the poll interval will exit,\n   *   cleanup, and call the listener back.\n   * If not started, the listener does not get called. This relationship\n   *   is set in html-snapshots.js: listener == notifier.start\n   *\n   * @param {Object} q - The worker queue, expected created by async.queue.\n   * @param {Function} q.length - Gets the worker queue length.\n   * @param {Object} [err] - The error object to set.\n   */\n  abort: function abort (q, err) {\n    this.csFactory(function (done) {\n      try {\n        // for each file, clearTimeout and delete the object\n        Object.keys(this.files).forEach(function(file) {\n          clearTimeout(this.files[file].timer);\n          delete this.files[file];\n        }, this);\n\n        // if nothing is waiting, make sure empty is set\n        this.qempty = !q.length();\n\n        // set the error\n        this._setError(err);\n      } catch (e) {\n        console.error(e);\n      }\n      done();\n    }.bind(this), L_WAIT)();\n  }\n};\n\nmodule.exports = {\n  Notifier: Notifier,\n  TIMEOUT_PAD_FLOOR: TIMEOUT_PAD_FLOOR\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/async/exists.js":"/**\n * exists.js\n *\n * Robust exists check for snapshot files.\n * Empirically, I found that either one of these NodeJS checks can fail,\n * but both don't. This is a workaround.\n *\n * Copyright (c) 2013 - 2017, Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\nvar fs = require(\"fs\");\nvar nodeCall = require(\"../common/node\");\n\n/**\n * Check if a path exists.\n *\n * @param {String} path - The full path to the file to check.\n * @param {Object} [options] - fileExists options.\n * @param {Boolean} [options.returnFile] - If true, resolve to input filename on\n * success. Otherwise, resolve to boolean. Defaults to false (boolean).\n * @returns {Promise} Resolves to true (or file) if exists, false otherwise.\n */\nfunction pathExists (path, options) {\n  options = options || {\n    returnFile: false\n  };\n\n  // Defaults to F_OK\n  return nodeCall(fs.access, path)\n    .then(function () {\n      return options.returnFile ? path : true;\n    })\n    .catch(function () {\n      if (fs.existsSync(path)) {\n        return options.returnFile ? path : true;\n      }\n      return false;\n    });\n}\n\nmodule.exports = pathExists;\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/common/node.js":"/***\n * nodeCall\n *\n * Copyright (c) 2013 - 2017, Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n/* global Promise */\n\"use strict\";\n\n/**\n * Utility to promisify a Node function\n *\n * @param {Function} nodeFunc - The node-style function to Promisify.\n */\nfunction nodeCall (nodeFunc /* args... */) {\n  var nodeArgs = Array.prototype.slice.call(arguments, 1);\n\n  return new Promise(function (resolve, reject) {\n    /**\n     * Resolve a node callback\n     */\n    function nodeResolver (err, value) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(value);\n      }\n    }\n\n    nodeArgs.push(nodeResolver);\n    nodeFunc.apply(nodeFunc, nodeArgs);\n  });\n}\n\nmodule.exports = nodeCall;\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/common/sitemap.js":"/**\n * sitemap.js\n *\n * An input generator for html-snapshots that uses a sitemap.xml file.\n * Creates the snapshot arguments driven from sitemap.xml urls.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar urlm = require(\"url\");\nvar zlib = require(\"zlib\");\nvar _ = require(\"lodash\");\nvar xml2js = require(\"xml2js\");\nvar request = require(\"request\");\nvar common = require(\"./index\");\nvar base = require(\"../input-generators/_base\");\n\n// the out of date fallback\nvar unixStart = \"1970-01-01T00:00:00.000Z\";\n\n// milliseconds for changefreq\nvar changeFreq = {\n  always: -Number.MAX_VALUE,\n  hourly: 3600000,\n  daily: 86400000,\n  weekly: 604800000,\n  monthly: 2629740000,\n  yearly: 31560000000,\n  never: Number.MAX_VALUE\n};\n\n/**\n * Return true if the urlNode is still current (not stale) by sitemap policy.\n * If both lastmod and changefreq tags are supplied both are used.\n * If only one of lastmod or changefreq are supplied,\n *   then they are compared against previous output if it exists.\n * If a test fails for any reason, it is characterized as stale (returns false).\n *\n * @param {Object} urlNode - Sitemap XML url node as an object.\n * @param {Object} options - Sitemap options object, passed through.\n */\nfunction stillCurrent (urlNode, options) {\n  var lesser, greater, oPath;\n  var now = Date.now();\n  var lMod = _.first(urlNode.lastmod);\n  var cFreq = _.first(urlNode.changefreq) ? _.first(urlNode.changefreq).toLowerCase() : null;\n\n  // only lastmod specified\n  if (lMod && !cFreq) {\n    // if sitemap is malformed, just blow up\n    oPath = base.outputFile(options, urlNode.loc[0]);\n\n    lesser = now - ( (fs.existsSync(oPath) && fs.statSync(oPath).mtime.getTime()) || unixStart );\n    greater = now - Date.parse(lMod);\n  }\n  // only changefreq specified\n  else if (!lMod && cFreq) {\n    // if sitemap is malformed, just blow up\n    oPath = base.outputFile(options, urlNode.loc[0]);\n\n    lesser = now - ( (fs.existsSync(oPath) && fs.statSync(oPath).mtime.getTime()) || unixStart );\n    greater = changeFreq[cFreq] || changeFreq.always;\n  }\n  // both or neither were specified\n  else {\n    lesser = now - Date.parse(lMod || unixStart);\n    greater = changeFreq[cFreq] || changeFreq.always;\n  }\n\n  return lesser <= greater;\n}\n\n/**\n * Parse a sitemap document\n * For each qualifying url element in urlset, call base.input\n * Stops processing if an error occurs.\n *\n * @param {Object} options - Sitemap options.\n * @param {String} options.source - The sitemap url or file.\n * @param {Boolean} options.sitemapPolicy - True if sitemapPolicy should be enforced.\n * @param {String} document - An xml document string.\n * @param {Function} callback - The completion callback.\n */\nfunction parse (options, document, callback) {\n  xml2js.parseString(document, {\n    trim: true,\n    normalizeTags: true,\n    normalize: true\n  }, function (err, result) {\n    var source = options.source;\n\n    if (!err) {\n\n      // Process the url input, but break if base.input returns false.\n      //   In other words, _.find is looking for a non-falsy err.\n      // For now, this can only happen if no outputDir is defined,\n      //   which is a fatal bad option problem and will happen immediately.\n      _.find(\n        // if the sitemap is malformed, just blow up\n        result.urlset.url,\n        function (urlNode) {\n          // optionally ignore current urls by sitemap policy\n          var url,\n              process = !options.sitemapPolicy ||\n                !stillCurrent(urlNode, options);\n\n          if (process) {\n            // if sitemap is malformed, just blow up\n            url = urlm.parse(urlNode.loc[0]);\n            if (!base.input(_.extend({}, options, {\n                protocol: url.protocol,\n                auth: url.auth,\n                hostname: url.hostname,\n                port: url.port\n              }),\n              urlNode.loc[0])\n            ) {\n              source = urlNode.loc[0];\n              err = base.generatorError();\n            }\n          }\n\n          return err;\n        }\n      );\n    }\n\n    callback(common.prependMsgToErr(err, source, true));\n  });\n}\n\n/**\n * Convert Buffer input, call next or callback with error\n *\n * @param {Object} options - Sitemap options.\n * @param {String} options.source - Sitemap URL.\n * @param {Buffer} buffer - A node buffer.\n * @param {Function} next - A function to run after optional conversion applied.\n * @param {Function} callback - A completion callback.\n */\nfunction convert(options, buffer, next, callback) {\n  var gunzip = path.extname(options.source) === \".gz\";\n\n  if (gunzip) {\n    zlib.gunzip(buffer, function (err, result) {\n      if (err) {\n        callback(common.prependMsgToErr(err, options.source, true));\n      } else {\n        next(options, result && result.toString(), callback);\n      }\n    });\n  }\n  else {\n    next(options, buffer.toString(), callback);\n  }\n}\n\n/**\n * Retrieve the sitemap from a url and call to parse it.\n *\n * @param {Object} options - Sitemap options.\n * @param {String} options.source - Sitemap URL.\n * @param {Function} options.timeout - User supplied run timeout.\n * @param {Function} parseFn - A data parser function.\n * @param {Function} callback - A completion callback function.\n */\nfunction getUrl (options, parseFn, callback) {\n  request({\n    url: options.source,\n    encoding: null,\n    timeout: options.timeout() // get the default timeout\n  }, function (err, res, body) {\n    var error = err || common.checkResponse(res, [\"text/xml\", \"application/xml\"]);\n\n    if (error) {\n      callback(common.prependMsgToErr(error, options.source, true));\n    } else {\n      convert(options, body, parseFn, callback);\n    }\n  });\n}\n\n/**\n * Retrieve the sitemap from a file and call to parse it.\n *\n * @param {Object} options - Sitemap options.\n * @param {String} options.source - Sitemap file path.\n * @param {Function} parseFn - A data parser function.\n * @param {Function} callback - A completion callback.\n */\nfunction getFile (options, parseFn, callback) {\n  fs.readFile(options.source, function (err, data) {\n    if (err) {\n      callback(common.prependMsgToErr(err, options.source, true));\n    } else {\n      convert(options, data, parseFn, callback);\n    }\n  });\n}\n\nmodule.exports = {\n  getFile: getFile,\n  getUrl: getUrl,\n  stillCurrent: stillCurrent,\n  parse: parse\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/input-generators/_base.js":"/**\n * _base.js\n *\n * The common, base functionality of an input generator.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nvar EventEmitter = require(\"events\").EventEmitter;\nvar path = require(\"path\");\nvar urlm = require(\"url\");\nvar _ = require(\"lodash\");\nvar common = require(\"../common\");\n\n// Defaults for this module\nvar defaults = Object.freeze({\n  protocol: \"http\",\n  hostname: \"localhost\",\n  port: undefined,\n  auth: undefined,\n  outputPath: undefined,\n  outputDir: \"./snapshots\",\n  selector: \"body\",\n  timeout: 10000,\n  checkInterval: 250,\n  useJQuery: false,\n  verbose: false,\n  phantomjsOptions: \"\"\n});\n\n/**\n * Normalize the given object to a function.\n *\n * If the input is a function, return it as is.\n * If the input is undefined, then a passthru function is generated.\n * If the input is NOT an Object, then a function returns that value.\n * If the input is an Object, then a function receives a key and\n *   returns the property value if it exists, otherwise return the __default value.\n *   If a passthru is requested, the key is returned when no __default is found.\n *\n * @param {Any} obj - Some input to be represented by a function.\n * @returns {Function} A function to represent the given input.\n */\nfunction normalize (obj) {\n  var result = obj;\n  if (typeof obj !== \"function\") {\n    if (typeof obj !== \"undefined\") {\n      if (Object.prototype.toString.call(obj) !== \"[object Object]\") {\n        result = (function (value) { return function () { return value; }; }(obj));\n      } else {\n        result = (function (o) { return function (key, passthru) {\n          if (o[key] === void 0) {\n            return o.__default || (passthru ? key : undefined);\n          } else {\n            return o[key];\n          }\n        }; }(obj));\n      }\n    } else {\n      result = function (passthru) { return passthru; };\n    }\n  }\n  return result;\n}\n\n/**\n * If a normalized option was overriden, but a default still undefined, supply one.\n * The result could still be undefined, but only if the default is undefined.\n *\n * If calling the normalized option with no args is undefined, supply missing default.\n *\n * @param {Object} options - Input generator options.\n * @param {String} name - The name of the property to supply missing default for.\n */\nfunction supplyMissingDefault (options, name) {\n  if (options[name]() === void 0) {\n    options[name] = _.wrap(options[name], function(func, key) {\n      var res = func(key);\n      return res === void 0 ? defaults[name] : res;\n    });\n  }\n}\n\n/**\n * Prepare options for use by an input generator.\n *\n * @param {Object} options - Input generator options with or without defaults.\n * @param {Function} listener - The input generator listener.\n */\nfunction prepOptions (options, listener) {\n  // Ensure defaults are represented\n  common.ensure(options, defaults);\n\n  // Normalize certain arguments if they are not functions.\n  // The certain arguments are per-page options.\n  // However, outputPath is a special case\n  [\n    \"selector\", \"timeout\", \"useJQuery\", \"verbose\", \"phantomjsOptions\"\n  ]\n  .forEach(function (perPageOption) {\n    options[perPageOption] = normalize(options[perPageOption]);\n    supplyMissingDefault(options, perPageOption);\n  });\n\n  options._inputEmitter = new EventEmitter();\n  options._inputEmitter.on(\"input\", listener);\n}\n\n/**\n * Get an output path for a page.\n *\n * Parse a given page as a url and return its corresponding outputPath.\n * If parse is an object, parse.url will be a reference to the url parse.\n * Returns false if no output path found.\n *\n * @param {Object} options - output path options.\n * @param {Function} options.outputPath - Derives the outputPath from page.\n * @param {String} page - The url to the page resource.\n * @param {Object} [parse] - Supply to get page (url) parse output in prop `url`.\n * @returns {String} The 'path' part of the file output path.\n */\nfunction getOutputPath (options, page, parse) {\n  var pagePart = urlm.parse(page),\n      // if outputPath was normalized with an object, let the key passthru\n      outputPath = options.outputPath(page, true);\n\n  // check for bad output path\n  if (!outputPath) {\n    return false;\n  }\n\n  // if the outputPath is really still a url, fix it to path+hash\n  if (common.isUrl(outputPath)) {\n    outputPath = pagePart.path + (pagePart.hash ? pagePart.hash : \"\");\n  }\n\n  // if the caller wants the url parse output, return it\n  if (parse) {\n    parse.url = pagePart;\n  }\n\n  return outputPath;\n}\n\n/**\n * Using the options, map the given page to an output path.\n *\n * @param {Object} options - The input generator options.\n * @param {String} options.outputDir - The output directory root path.\n * @param {String} [options.outputPath] - optional function or object to map pages to outputPaths.\n * @param {String} [options.sitemapOutputDir] - optional root path for sitemaps within outputDir.\n * @returns {String|Boolean} The full path to the output file or false on failure.\n */\nfunction mapOutputFile (options, page, parse) {\n  if (!_.isFunction(options.outputPath)) {\n    options.outputPath = normalize(options.outputPath);\n  }\n\n  var outputPath = getOutputPath(options, page, parse);\n  var outputDir = options.outputDir;\n  var fileName = \"index.html\";\n\n  if (options.sitemapOutputDir) {\n    outputDir = path.join(options.outputDir, options.sitemapOutputDir);\n    fileName = \"\";\n  }\n\n  return ( outputPath && path.join(outputDir, outputPath, fileName) ) || false;\n}\n\n/*\n * Interface consumed by input generators\n *\n * Consumption pattern call order:\n * <Setup Phase>\n *   [defaults]\n * <Start Processing>\n *   run\n * <For each page, specialized>\n *   input\n * <End Processing>\n *   EOI\n */\nmodule.exports = {\n\n  /**\n   * Add specific items to the defaults.\n   * Not required if the generator has no defaults itself.\n   *\n   * @param {Object} specific - Input generator specific defaults.\n   * @return {Object} The fully mixed defaults.\n   */\n  defaults: function (specific) {\n    return Object.assign({}, defaults, specific);\n  },\n\n  /**\n   * Run the input generator.\n   *\n   * @param {Object} options - Input generator options.\n   * @param {Function} generator - The input generator to run.\n   * @param {Function} listener - The callback that receives each input generated.\n   * @returns {Promise} The promise returned by the input generator.\n   */\n  run: function (options, generator, listener) {\n    options = options || {};\n    prepOptions(options, listener);\n    return generator(options);\n  },\n\n  /**\n   * Generate the input\n   * Emit the event that contains the input hash\n   *\n   * @param {Object} options - input generator options.\n   * @param {String} options.protocol - https?\n   * @param {String} options.auth - user:pass for old style urls.\n   * @param {String} options.hostname - The hostname part of the url.\n   * @param {Number} options.port - The port part of the url.\n   * @param {Function} options.selector - Produces a selector given a page url.\n   * @param {Function} options.timeout - Produces a timeout given a page url.\n   * @param {Number} options.checkInterval - The millisecond resolute poll interval.\n   * @param {Function} options.userJQuery - Produces a jquery bool given a page url.\n   * @param {Function} options.verbose - Produces a verbose bool given a page url.\n   * @param {Function} options.phantomjsOptions - Produces phantomjs options given a page url.\n   * @param {Function} options._inputEmitter - The EventEmitter to generate input.\n   * @param {String} page - The url to the page resource.\n   * @returns {String} The full output file path.\n   */\n  input: function (options, page) {\n    var parse = {};\n    var outputFile = mapOutputFile(options, page, parse);\n\n    if (outputFile) {\n\n      options._inputEmitter.emit(\"input\", {\n        outputFile: outputFile,\n        // make the url\n        url: urlm.format({\n                protocol: options.protocol,\n                auth: options.auth,\n                hostname: options.hostname,\n                port: options.port,\n                pathname: parse.url.pathname,\n                search: parse.url.search,\n                hash: parse.url.hash\n              }),\n        // map the input page to a selector\n        selector: options.selector(page),\n        // map the input page to a timeout\n        timeout: options.timeout(page),\n        checkInterval: options.checkInterval,\n        // map the input page to a useJQuery flag\n        useJQuery: options.useJQuery(page),\n        // map the input page to a verbose flag\n        verbose: options.verbose(page),\n        // map the input page to phantomJS options\n        phantomjsOptions: options.phantomjsOptions(page),\n        // useful for testing, debugging\n        __page: page\n      });\n\n    }\n\n    return outputFile;\n  },\n\n  /**\n   * Signal the end of input\n   *\n   * @param {Object} generator - The input generator.\n   */\n  EOI: function (generator) {\n    generator.EOI = function () { return true; };\n  },\n\n  /**\n   * Expose the output file mapping utility function.\n   *\n   * @see mapOutputFile.\n   */\n  outputFile: mapOutputFile,\n\n  /**\n   * Unified input generator error.\n   *\n   * @returns {Error} The generic input generator failure error.\n   */\n  generatorError: function () {\n    return new Error(\"Failed to generate input\");\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/input-generators/array.js":"/*\n * array.js\n *\n * An input generator for html-snapshots that uses a javascript array\n *   to generate snapshot input from the host relative page urls.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n/* global Promise */\n\"use strict\";\n\nvar urlm = require(\"url\");\nvar common = require(\"../common\");\nvar base = require(\"./_base\");\n\nvar array;\n\n/**\n * Generate the snapshot arguments from an array of pages.\n * Stops processing if one fails.\n *\n * @param {Object} options - input generator options object.\n * @param {String} options.source - Array of urls.\n * @param {Function} options._abort - Called to abort the output watcher.\n * @returns {Promise} Resolves to undefined on success.\n */\nfunction generateInput (options) {\n  var result = new Promise(function (resolve, reject) {\n    var all;\n\n    if (Array.isArray(options.source)) {\n      all = options.source.every(function (sourceUrl) {\n        var url = urlm.parse(sourceUrl);\n        var opts = Object.assign({}, options, {\n          protocol: url.protocol,\n          auth: url.auth,\n          hostname: url.hostname,\n          port: url.port\n        });\n\n        if (!base.input(opts, sourceUrl)) {\n          reject(\n            common.prependMsgToErr(base.generatorError(), sourceUrl, true)\n          );\n          return false;\n        }\n\n        return true;\n      });\n\n      if (all) {\n        resolve();\n      }\n    } else {\n      reject(new Error(\"options.source must be an array\"));\n    }\n  });\n\n  return result\n    .catch(function (error) {\n      options._abort(error);\n    })\n    .then(function () {\n      base.EOI(array);\n    });\n}\n\narray = module.exports = {\n  /**\n   * Generate the input arguments for snapshots from an array.\n   *\n   * @param {Object} options - Array generator options.\n   * @param {Function} listener - Callback to receive each input.\n   * @returns {Promise} Resolves to undefined on completion.\n   */\n  run: function (options, listener) {\n    return base.run(options, generateInput, listener);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/input-generators/robots.js":"/*\n * robots.js\n *\n * An input generator for html-snapshots that uses a simple robots.txt file.\n * Creates the snapshot arguments driven from robots.txt \"Allow: \".\n * Does not support wildcards.\n * If you need wildcards, use the sitemap input generator.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nvar fs = require(\"fs\");\nvar request = require(\"request\");\nvar common = require(\"../common\");\nvar nodeCall = require(\"../common/node\");\nvar base = require(\"./_base\");\n\n// The default options\nvar defaults = Object.freeze({\n  source: \"./robots.txt\",\n  hostname: \"localhost\"\n});\n\nvar robots;\n\n/**\n * Generate input for one line of a simple robots.txt file\n * Does not support wildcards.\n */\nfunction oneline (line, options) {\n  var key = \"Allow: \",\n      index = line.indexOf(key);\n\n  if (index !== -1) {\n    var page = line.substr(index + key.length).replace(/^\\s+|\\s+$/g, \"\");\n    return page.indexOf(\"*\") === -1 && base.input(options, page);\n  }\n\n  return true;\n}\n\n/**\n * Retrieves robots.txt from url and parses it.\n *\n * @param {Object} options - Robots.txt options\n * @param {String} options.source - The URL to a robots.txt\n * @param {Function} options.timeout - Returns the robots.txt request timeout.\n * @param {Function} callback - A completion callback.\n */\nfunction getRobotsUrl (options, callback) {\n  request({\n    url: options.source,\n    timeout: options.timeout()\n  }, function (err, res, body) {\n    var error = err || common.checkResponse(res, \"text/plain\");\n\n    if (error) {\n      callback(common.prependMsgToErr(error, options.source, true));\n    } else {\n      body.toString().split('\\n').every(function(line) {\n        // Process the line input, but break if base.input returns false.\n        // For now, this can only happen if no outputDir is defined,\n        //   which is a fatal bad option problem and will happen immediately.\n        if (!oneline(line, options)) {\n          error = common.prependMsgToErr(base.generatorError(), line, true);\n          return false;\n        }\n        return true;\n      });\n\n      callback(error);\n    }\n  });\n}\n\n/**\n * Reads the robots.txt file and parses it.\n */\nfunction getRobotsFile (options, callback) {\n  fs.readFile(options.source, function (err, data) {\n    if (!err) {\n      data.toString().split('\\n').every(function (line) {\n        // Process the line input, but break if base.input returns false.\n        // For now, this can only happen if no outputDir is defined,\n        //   which is a fatal bad option problem and will happen immediately.\n        if (!oneline(line, options)) {\n          err = common.prependMsgToErr(base.generatorError(), line, true);\n          return false;\n        }\n        return true;\n      });\n    }\n\n    callback(err);\n  });\n}\n\n/**\n * Generate the snapshot arguments from a robots.txt file.\n * Each line that has \"Allow:\" contains a url we need a snapshot for.\n * This can return true on error for true async. An async error is supplied to listener\n * in this case via _abort.\n *\n * @param {Object} options - input generator options object.\n * @param {String} options.source - A url or file path.\n * @param {Function} options._abort - Abort function to stop the async notifier.\n * @returns {Promise} Resolves to undefined on completion.\n */\nfunction generateInput (options) {\n  return nodeCall(\n    common.isUrl(options.source) ? getRobotsUrl : getRobotsFile,\n    options\n  )\n    .catch(function (err) {\n      options._abort(err);\n    })\n    .then(function () {\n      base.EOI(robots);\n    });\n}\n\nrobots = module.exports = {\n  /**\n   * Generate the input arguments for snapshots from a robots.txt file\n   * Each input argument generated calls the listener passing the input object.\n   *\n   * @param {Object} options - Robots options.\n   * @param {Function} listener - Callback to receive each input.\n   * @returns {Promise} Resolves to undefined on completion.\n   */\n  run: function (options, listener) {\n    var opts = Object.assign({}, base.defaults(defaults), options);\n\n    return base.run(opts, generateInput, listener);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/input-generators/textfile.js":"/*\n * textfile.js\n *\n * An input generator for html-snapshots that uses a simple text file\n *   with the host relative page urls, one per line.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\"use strict\";\n\nvar fs = require(\"fs\");\nvar base = require(\"./_base\");\nvar common = require(\"../common\");\nvar nodeCall = require(\"../common/node\");\n\n// The default options\nvar defaults = Object.freeze({\n  source: \"./line.txt\",\n  hostname: \"localhost\"\n});\n\nvar textfile;\n\n/**\n * Generate the snapshot arguments from a line oriented text file.\n * Each line contains a single url we need a snapshot for.\n *\n * @param {Object} options - input generator options object.\n * @param {String} options.source - path to the local input file.\n * @returns {Promise} resolves when complete.\n */\nfunction generateInput (options) {\n  return nodeCall(\n    fs.readFile,\n    options.source\n  )\n    .catch(function (err) {\n      options._abort(err);\n    })\n    .then(function (data) {\n      var error;\n\n      if (data) {\n        data.toString().split('\\n').every(function (line) {\n          var page = line.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (!base.input(options, page)) {\n            error = common.prependMsgToErr(base.generatorError(), page, true);\n            return false;\n          }\n          return true;\n        });\n\n        if (error) {\n          console.error(error);\n          options._abort(error);\n        }\n      }\n\n      base.EOI(textfile);\n    });\n}\n\ntextfile = module.exports = {\n  /**\n   * Generate the input arguments for snapshots from a simple, line oriented\n   * text file.\n   *\n   * @param {Object} options - Text file options.\n   * @param {Function} listener - Callback to receive each input.\n   * @returns {Promise} Resolves to undefined on completion.\n   */\n  run: function (options, listener) {\n    var opts = Object.assign({}, base.defaults(defaults), options);\n\n    return base.run(opts, generateInput, listener);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/phantom/customFilter.js":"/*\n * customFilter.js\n *\n * Produce a single snapshot for a web page.\n * Snapshot taken when selector is(:visible).\n * Applies a custom filter to the snapshot output.\n *\n * This is a phantomJS script that runs in phantomjs.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\nvar selectorDetect = require(\"./modules/selectorDetect\");\nvar cli = require(\"./modules/cli\");\nvar detectors = require(\"./modules/detectors\");\n\nvar options = cli.selector();\nvar customFilter = require(options.module);\n\nselectorDetect(\n  options,\n  options.useJQuery ? detectors.jquerySelector : detectors.querySelector,\n  customFilter\n);\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/phantom/modules/selectorDetect.js":"/*\n * selectorDetect.js\n *\n * Produce a single snapshot for a web page when a given selector is detected.\n *\n * This is a module for a phantomJS script that runs in phantomjs.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\n\n// Get the start time immediately since we're already in a PhantomJS process instance\n// The spawner is already counting down (with allowances)...\nvar start = new Date().getTime();\n\n/**\n * Dependencies, phantomjs\n */\nvar page = require(\"webpage\").create();\nvar fs = require(\"fs\");\nvar globals = require(\"./globals\");\nvar verbose = require(\"./verbose\");\n\n/**\n * waitFor\n *\n * Heavily borrowed from phantomJS 'waitFor' example\n */\nfunction waitFor (testFx, onReady, onTimeout, timeout, checkInterval) {\n  var condition = false,\n  interval = setInterval(function () {\n    if ( (new Date().getTime() - start < timeout) && !condition ) {\n      // If not timeout yet and condition not yet fulfilled\n      condition = testFx();\n    } else {\n      clearInterval(interval); // Stop this interval\n      if ( !condition ) {\n        // If condition still not fulfilled (timeout but condition is 'false')\n        onTimeout();\n      } else {\n        // Condition fulfilled (timeout and/or condition is 'true')\n        onReady((new Date().getTime() - start));\n      }\n    }\n  }, checkInterval);\n}\n\n/**\n * snapshot\n *\n * Opens the page and waits for the selector to become visible. Then takes the html snapshot.\n * Applies an optional output filter to the html content.\n *\n */\nfunction snapshot (options, detector, filter) {\n  filter = filter || function(content) { return content; };\n\n  console.log(\"Creating snapshot for \"+options.url+\"...\");\n\n  // https://github.com/ariya/phantomjs/issues/10930\n  page.customHeaders = {\n    \"Accept-Encoding\": \"identity\"\n  };\n\n  // add optional verbose output\n  if (options.verbose) {\n    verbose(page);\n  }\n\n  // create the snapshot\n  page.open(options.url, {\n    resourceTimeout: options.timeout - 300 // a little space to report problems.\n  }, function (status) {\n    if (status !== \"success\") {\n      // if phantomJS could not load the page, so end right now\n      globals.exit(2, \"Unable to load page \" + options.url);\n    } else {\n      // phantomJS loaded the page, so wait for it to be ready\n      waitFor(\n\n        // The test to determine readiness\n        function () {\n          return page.evaluate(detector, {\n            selector: options.selector,\n            url: options.url\n          });\n        },\n\n        // The onReady callback\n        function (time) {\n          fs.write(options.outputFile, filter(page.content), \"w\");\n          globals.exit(0, \"snapshot for \"+options.url+\" finished in \"+time+\" ms\\n  written to \"+options.outputFile);\n        },\n\n        // The onTimeout callback\n        function () {\n          globals.exit(1, \"timed out waiting for \"+options.selector+\" to become visible for \"+options.url);\n        },\n\n        options.timeout,\n        options.checkInterval\n\n      );\n    }\n  });\n}\n\nmodule.exports = snapshot;\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/phantom/default.js":"/*\n * default.js\n *\n * Produce a single snapshot for a web page.\n * Snapshot taken when a selector is detected visible.\n *\n * This is a phantomJS script that runs in phantomjs.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\nvar selectorDetect = require(\"./modules/selectorDetect\");\nvar cli = require(\"./modules/cli\");\nvar detectors = require(\"./modules/detectors\");\n\nvar options = cli.selector();\n\nselectorDetect(\n  options,\n  options.useJQuery ? detectors.jquerySelector : detectors.querySelector\n);\n","/home/travis/build/npmtest/node-npmtest-html-snapshots/node_modules/html-snapshots/lib/phantom/removeScripts.js":"/*\n * removeScripts.js\n *\n * Produce a single snapshot for a web page.\n * Snapshot taken when selector is(:visible).\n * Applies a single filter to remove any script tags.\n *\n * This is a phantomJS script that runs in phantomjs.\n *\n * Copyright (c) 2013 - 2017 Alex Grant, LocalNerve, contributors\n * Licensed under the MIT license.\n */\nvar selectorDetect = require(\"./modules/selectorDetect\");\nvar cli = require(\"./modules/cli\");\nvar detectors = require(\"./modules/detectors\");\n\n/**\n * Remove all script tags from content\n */\nfunction removeScriptTags(content) {\n  return content.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\");\n}\n\nvar options = cli.selector();\n\nselectorDetect(\n  options,\n  options.useJQuery ? detectors.jquerySelector : detectors.querySelector,\n  removeScriptTags\n);\n"}